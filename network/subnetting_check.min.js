const colorBg = ["#97C2FC", "#FFFF00", "#FB7E81", "#7BE141", "#EB7DF4", "#AD85E4"];
const colorBd = ["#2B7CE9", "#FFA500", "#FA0A10", "#41A906", "#E129F0", "#7C29F0"];
const colorHlBg = ["#D2E5FF", "#FFFFA3", "#FFAFB1", "#A1EC76", "#F0B3F5", "#D3BDF0"];
const colorHlBd = ["#2B7CE9", "#FFA500", "#FA0A10", "#41A906", "#E129F0", "#7C29F0"];
var nodes;
var edges;
const nodeFilters = document.getElementsByName("nodesFilter");
const edgeFilters = document.getElementsByName("edgesFilter");
var sAA;
var sAB;
var sAC = -1;
var sAD = [];
var sAE = [];
var sAF = [];
var sAG = [];
const maxRouter = 5;
var sAH = [true, true, true, true, true];
function sAI(msg) {
    let sAJ = document.getElementById("logs");
    msg = sAJ.value + msg + "\n>";
    sAJ.value = msg;
}
function sAK(sCE) {
    let sAL = sCE.split(".");
    let sAM = [];
    for (let addrField of sAL) {
        while (addrField.startsWith("0")) {
            addrField = addrField.substring(1);
        }
        if (addrField == "") {
            addrField = "0";
        }
        sAM.push(addrField);
    }
    sCE = sAM.join(".");
    return sCE;
}
function sAN(sCE) {
    let sAL = sCE.split(".");
    if (sAL.length < 4) {
        return false;
    }
    let sAO = sAL2Bin(sAL);
    let sAP = sAO2Str(sAO);
    if (sAP == sCE) {
        return true;
    } else {
        return false;
    }
}
function sAQ(maskDec) {
    if (-1 < maskDec && maskDec < 33) {
        return true;
    }
    return false;
}
function sAR(sAL, sBV) {
    let sAS = new Array(0, 0, 0, 0);
    for (let iDigit = 0; iDigit < 4; iDigit++) {
        sAS[iDigit] = sAL[iDigit] & sBV[iDigit];
    }
    return sAS;
}
function sAT(ipAddress, maskIP) {
    let sAU = sBP(ipAddress);
    let sAV = sBP(maskIP);
    let sAW = [];
    for (let jMask = 0; jMask < sAV.length; jMask++) {
        sAW.push(sBI(sAU[jMask], sAV[jMask]));
    }
    let sAX = sBN(sAW);
    let sAY = "";
    for (let kNetwork = 0; kNetwork < sAX.length; kNetwork++) {
        sAY += sAX[kNetwork] + ".";
    }
    return sAY.slice(0, -1);
}
function sAZ(ipAddress, maskIP) {
    let sAU = sBP(ipAddress);
    let sAV = sBP(maskIP);
    let sBA = [];
    for (let iMask = 0; iMask < sAV.length; iMask++) {
        sBA.push(sBE(sAV[iMask]));
    }
    let sBB = [];
    for (let jMask = 0; jMask < sAV.length; jMask++) {
        sBB.push(sBM(sAU[jMask], sBA[jMask]));
    }
    let sBC = sBN(sBB);
    let sBD = "";
    for (let kBroadcast = 0; kBroadcast < sBC.length; kBroadcast++) {
        sBD += sBC[kBroadcast] + ".";
    }
    return sBD.slice(0, -1);
}
function sBE(number) {
    var sBF = number + "";
    var sBG = sBF.split("");
    var sBH = "";
    for (var i = 0; i < sBG.length; i++) {
        if (sBG[i] == "0") {
            sBH += "1";
        } else {
            sBH += "0";
        }
    }
    return sBH;
}
function sBI(firstBinary, secondBinary) {
    var sBJ = [];
    var sBK = [];
    sBJ = firstBinary.split("");
    sBK = secondBinary.split("");
    var sBL = "";
    for (var iFirst = 0; iFirst < sBJ.length; iFirst++) {
        if (sBJ[iFirst] + "+" + sBK[iFirst] == "1+0") {
            sBL += "0";
        } else if (sBJ[iFirst] + "+" + sBK[iFirst] == "0+1") {
            sBL += "0";
        } else if (sBJ[iFirst] + "+" + sBK[iFirst] == "1+1") {
            sBL += "1";
        } else if (sBJ[iFirst] + "+" + sBK[iFirst] == "0+0") {
            sBL += "0";
        }
    }
    return sBL;
}
function sBM(firstBinary, secondBinary) {
    var sBJ = [];
    var sBK = [];
    sBJ = firstBinary.split("");
    sBK = secondBinary.split("");
    var sBL = "";
    for (var iFirst = 0; iFirst < sBJ.length; iFirst++) {
        if (sBJ[iFirst] + "+" + sBK[iFirst] == "1+0") {
            sBL += "1";
        } else if (sBJ[iFirst] + "+" + sBK[iFirst] == "0+1") {
            sBL += "1";
        } else if (sBJ[iFirst] + "+" + sBK[iFirst] == "1+1") {
            sBL += "1";
        } else if (sBJ[iFirst] + "+" + sBK[iFirst] == "0+0") {
            sBL += "0";
        }
    }
    return sBL;
}
function sBN(sAUArr) {
    var sBO = [];
    for (var iBinary = 0; iBinary < sAUArr.length; iBinary++) {
        sBO.push(parseInt(parseInt(sAUArr[iBinary]), 2));
    }
    return sBO;
}
function sBP(ipAddress) {
    var sBQ = ipAddress.split(".");
    var sAU = [];
    for (var iIp = 0; iIp < sBQ.length; iIp++) {
        var sBR = parseInt(sBQ[iIp]).toString(2);
        if (sBR.length == 8) {
            sAU.push(sBR);
        } else {
            var sBS = 8 - sBR.length;
            var sBT = "";
            for (var jDiff = 0; jDiff < sBS; jDiff++) {
                sBT += "0";
            }
            sBT += sBR;
            sAU.push(sBT);
        }
    }
    return sAU;
}
function sBU(sCE, maskDec) {
    let sBV = sBZ(maskDec);
    let sBW = sBV.join(".");
    let sBX = sAT(sCE, sBW);
    let sBY = sAZ(sCE, sBW);
    if (sCE == sBX || sCE == sBY) {
        return true;
    }
    return false;
}
function sBZ(maskDec) {
    let sCA = "".padStart(32 - maskDec, "0").padStart(32, "1");
    let sBV = [];
    for (let iDigit = 0; iDigit < 4; iDigit++) {
        let sCB = sCA.slice(iDigit * 8, iDigit * 8 + 8);
        sBV.push(parseInt(sCB, 2));
    }
    return sBV;
}
function sAL2Bin(sAL) {
    var sAO = "";
    for (let iDigit = 0; iDigit < sAL.length; iDigit++) {
        sAO = sAO + parseInt(sAL[iDigit]).toString(2).padStart(8, "0");
    }
    return sAO;
}
function sAL2Str(sAL) {
    var sCE = "";
    for (let iDigit = 0; iDigit < sAL.length; iDigit++) {
        sCE = sCE + parseInt(sAL[iDigit]) + ".";
    }
    sCE = sCE.slice(0, sCE.length - 1);
    return sCE;
}
function sAO2Str(sAO) {
    let sCE = [];
    for (let iDigit = 0; iDigit < 4; iDigit++) {
        let sCB = sAO.slice(iDigit * 8, iDigit * 8 + 8);
        sCE = sCE + parseInt(sCB, 2) + ".";
    }
    sCE = sCE.slice(0, sCE.length - 1);
    return sCE;
}
function sCG(sGF) {
    return { addr: sGF.split(",")[0], mask: sGF.split(",")[1], gateway: sGF.split(",")[2] };
}
function sCH(sCE, maskDec, gatewayStr) {
    let sCI = sCE + "," + maskDec + "," + gatewayStr;
    return sCI;
}
function sCJ() {
    var sCK = "0123456789abcdef";
    var sCL = "08:";
    for (var iDigit = 1; iDigit < 6; iDigit++) {
        sCL += sCK.charAt(Math.round(Math.random() * 15));
        sCL += sCK.charAt(Math.round(Math.random() * 15));
        if (iDigit != 5) sCL += ":";
    }
    return sCL;
}
function sCM(sCA, maskDec) {
    let sCN = sCA.slice(0, maskDec);
    let sCO = "";
    for (let iBit = 0; iBit < sCN.length; iBit += 8) {
        let sCP = Math.min(iBit + 8, sCN.length);
        sCO = sCO + sCN.slice(iBit, sCP) + ".";
    }
    sCO = sCO.slice(0, sCO.length - 1);
    let sCQ = sCA.slice(maskDec, 32);
    let sCR = "";
    for (let iBit = sCQ.length; iBit >= 0; iBit -= 8) {
        let sCP = Math.max(iBit - 8, 0);
        sCR = sCQ.slice(sCP, iBit) + "." + sCR;
    }
    sCR = sCR.slice(0, sCR.length - 1);
    sCA = sCO + " | " + sCR;
    return sCA;
}
function sCS(sCE) {
    return [8, 16, 24][Math.log2((sCE.slice(0, 3) ^ 255) | 8) ^ 7];
}
function sCT(labelStr) {
    return { addr: labelStr.split("/")[0], mask: labelStr.split("/")[1] };
}
function sCU(sCE, maskDec) {
    if (!sAN(sCE)) {
        sAI("Invalid address on the interface : " + sCE);
    }
    if (!sAQ(maskDec)) {
        sAI("Invalid mask on the interface : " + maskDec);
    }
    if (sAN(sCE) && sAQ(maskDec)) {
        if (sBU(sCE, maskDec)) {
            sAI("Reserved address on the interface : " + sCE);
        }
    }
}
function sCV(sCE, maskDec) {
    if (sAN(sCE) && sAQ(maskDec)) {
        let sCW = sCS(sCE);
        if (sCW == maskDec) {
            addrType = "standard";
        }
        if (sCW < maskDec) {
            addrType = "subnet";
        }
        if (sCW > maskDec) {
            addrType = "classless";
        }
    } else {
        sAI("Invalid address or mask on the interface " + sCE + " & " + maskDec);
        addrType = "bad_interface";
    }
    return addrType;
}
function sCX(sCE, maskDec, gatewayStr) {
    let sCY = "no_gateway";
    if (sAN(sCE) && sAQ(maskDec)) {
        let sCZ = sCE.split(".");
        let sBV = sBZ(maskDec);
        let sDA = sAR(sCZ, sBV);
        let sDB = sAL2Str(sDA);
        if (sDB == sCE) {
            if (gatewayStr != "") {
                if (sAN(gatewayStr)) {
                    sCY = "add_gateway";
                } else {
                    sAI("Invalid gateway address! " + sCE);
                    sCY = "bad_route";
                }
            }
        } else {
            sAI("Invalid destination address in the routing table " + sCE + " & " + maskDec);
            sCY = "bad_route";
        }
    } else {
        sAI("Invalid address or mask in the routing table " + sCE + " & " + maskDec);
        sCY = "bad_route";
    }
    return sCY;
}
function sDC(sDP, sDQ, sDDList, sDEList, sDFList) {
    sEV = sCV(sDP, sDQ);
    for (let iRoute = 0; iRoute < sDDList.length; iRoute++) {
        let sDD = sDDList[iRoute];
        let sDE = sDEList[iRoute];
        let sDF = sDFList[iRoute];
        sCY = sCX(sDD, sDE, sDF);
        if (sCY != "no_gateway") {
            sEV = sCY;
        }
        if (sCY == "bad_route") {
            break;
        }
    }
    return sEV;
}
function sDG(sDO, sEV, sDP, sDQ, sDR, sDS, sDT) {
    let sDH = {};
    if (sDO.startsWith("router")) {
        sEV = "router";
    }
    sDH["cat"] = sDO;
    sDH["type"] = sEV;
    sDH["addr"] = sDP;
    sDH["mask"] = sDQ;
    sDH["network"] = sDR;
    sDH["route"] = sDS;
    sDH["ethernet"] = sDT;
    sAD.push(sDH);
}
function sDI(csvFile) {
    let sDJ = 0;
    let sDK = csvFile.split("\n");
    for (let iLine = 1; iLine < sDK.length; iLine++) {
        let sDL = sDK[iLine].replace("\r", "");
        let sDM = sDL.split(";");
        let sDN = sDM[0].trim();
        if (sDN == "") {
            continue;
        }
        switch (sDN) {
            case "station":
            case sDN.startsWith("router") ? sDN : "":
                if (0 < sDJ) {
                    sEV = sDC(sDP, sDQ, sDDList, sDEList, sDFList);
                    sDG(sDO, sEV, sDP, sDQ, sDR, sDS, sDT);
                }
                var sDO = sDN;
                var sDP = sDM[1].trim();
                var sDQ = sDM[2].trim();
                var sDR = sEL(sDM[4].trim());
                var sDS = "";
                var sDT = sDM[5];
                if (sDT == "" || sDT === undefined) {
                    sDT = sCJ();
                } else {
                    sDT = sDT.trim();
                }
                sDP = sAK(sDP);
                sCU(sDP, sDQ);
                sDJ = sDJ + 1;
                var sDU = true;
                var sDDList = [];
                var sDEList = [];
                var sDFList = [];
                break;
            case "routing table":
                if (0 == sDJ) {
                    break;
                }
                if (!sDU) {
                    sDS = sDS + ";";
                }
                sDU = false;
                var sDD = sDM[1].trim();
                var sDE = sDM[2].trim();
                var sDF = sDM[3].trim();
                sDDList.push(sDD);
                sDEList.push(sDE);
                sDFList.push(sDF);
                sDS = sDS + sDD + "," + sDE + "," + sDF;
                break;
        }
    }
    if (0 < sDJ) {
        sEV = sDC(sDP, sDQ, sDDList, sDEList, sDFList);
        sDG(sDO, sEV, sDP, sDQ, sDR, sDS, sDT);
    }
}
function sDY() {
    sAE.forEach((network) => {
        sEA = sDZ(network);
    });
}
function sDZ(network) {
    let sEA = {};
    let sEB = 100 + network;
    sEA["id"] = sEB;
    sEA["label"] = "Switch";
    sEA["group"] = network;
    sEA["mass"] = 4;
    sEA["cat"] = "switchEth";
    sEA["type"] = "switchEth";
    sEA["shape"] = "circle";
    sAF.push(sEA);
    return sEA;
}
function sEC(content) {
    var sED = document.createElement("div");
    var sEE = "";
    sEE = sEE + "<table>";
    sEE = sEE + "<tr>";
    sEE = sEE + "<th>Destination</th>";
    sEE = sEE + "<th>Mask</th>";
    sEE = sEE + "<th>Gateway</th>";
    sEE = sEE + "</tr>";
    var sDLsTab = content.split(";");
    for (let iLine = 0; iLine < sDLsTab.length; iLine++) {
        sEE = sEE + "<tr>";
        var sEG = sDLsTab[iLine].split(",");
        for (let iField = 0; iField < sEG.length; iField++) {
            sEE = sEE + "<td>" + sEG[iField] + "</td>";
        }
        sEE = sEE + "</tr>";
    }
    sEE = sEE + "</table>";
    sED.innerHTML = sEE;
    return sED;
}
function sEH(sFI, sFUSliced, sES, sFM, sFSSliced, dstSubnetIDsFS) {
    var sED = document.createElement("div");
    var sEE = "";
    sEE = sEE + "Target " + sFI + "</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#11183;";
    sEE = sEE + "<table>";
    sEE = sEE + "<tr>";
    sEE = sEE + "<th>Destination</th>";
    sEE = sEE + "<th>Mask</th>";
    sEE = sEE + "<th>Gateway</th>";
    sEE = sEE + "</tr>";
    var sDLsTab = sES.split(";");
    for (let iLine = 0; iLine < sDLsTab.length; iLine++) {
        sEE = sEE + "<tr>";
        var sEG = sDLsTab[iLine].split(",");
        for (let iField = 0; iField < sEG.length; iField++) {
            sEE = sEE + "<td>" + sEG[iField] + "</td>";
        }
        sEE = sEE + "</tr>";
    }
    sEE = sEE + "</table>";
    sEE = sEE + "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#11183;</br>";
    sEE = sEE + "Match destination " + sFM + "</br></br>";
    sEE = sEE + "&nbsp;&nbsp;Target " + sFUSliced + "</br>";
    sEE = sEE + "& &nbsp;Mask " + sFSSliced + "</br>";
    sEE = sEE + "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10149;" + dstSubnetIDsFS;
    sED.innerHTML = sEE;
    return sED;
}
function sEI() {
    if (sAB !== null) {
        sAB.sEI();
        sAB = null;
    }
}
function sEJ() {
    document.getElementById("saveButton").onclick = null;
    document.getElementById("cancelButton").onclick = null;
    document.getElementById("network-popUp").style.display = "none";
}
function sEK(callback) {
    sEJ();
    callback(null);
}
function sEL(sEN) {
    sEN = Math.min(sEN, colorBg.length);
    sEN = Math.max(sEN, 1);
    return sEN.toString();
}
function sEM(data, callback) {
    data.id = document.getElementById("node-id").value;
    let sEN = document.getElementById("node-network-number").value;
    let sEO = sEL(sEN);
    if (data.id == -1) {
        sAC = sAC + 1;
        let sEP = {};
        sAF.splice(sAC, 0, sEP);
        data.id = sAC;
    } else {
        let sEQ = sEN - 1;
        data.color.background = colorBg[sEQ];
        data.color.border = colorBd[sEQ];
        data.color.highlight.background = colorHlBg[sEQ];
        data.color.highlight.border = colorHlBd[sEQ];
    }
    let sDP = document.getElementById("node-address").value.trim();
    let sDQ = document.getElementById("node-mask").value.trim();
    sDP = sAK(sDP);
    sCU(sDP, sDQ);
    data.label = sDP + "/" + sDQ;
    data.address = sDP + "/" + sDQ;
    data.group = sEO;
    data.cat = document.getElementById("node-cat").value;
    let sER = document.getElementById("node-ethernet");
    data.ethernet = sER.rows[0].cells[1].textContent;
    let sDT = data.ethernet;
    let sDO = data.cat;
    let sDR = data.group;
    var sES = "";
    var sDU = true;
    var sDS = "";
    var sDDList = [];
    var sDEList = [];
    var sDFList = [];
    for (iLine = 1; iLine < 5; iLine++) {
        let sDD = document.getElementById("node-routing-destination-" + iLine.toString()).value.trim();
        let sDE = document.getElementById("node-routing-mask-" + iLine.toString()).value.trim();
        let sDF = document.getElementById("node-routing-gateway-" + iLine.toString()).value.trim();
        if (sDD.trim() == "") {
            break;
        }
        if (!sDU) {
            sDS = sDS + ";";
        }
        sDU = false;
        sDDList.push(sDD);
        sDEList.push(sDE);
        sDFList.push(sDF);
        sDS = sDS + sDD + "," + sDE + "," + sDF;
    }
    data.route = sDS;
    data.title = sEC(sDS);
    sEV = sDC(sDP, sDQ, sDDList, sDEList, sDFList);
    if (data.cat.startsWith("router")) {
        sEV = "router";
        let sET = data.cat.substr(data.cat.length - 1);
        sAH[sET] = true;
    }
    data.type = sEV;
    if (sEV == "bad_interface" || sEV == "bad_route") {
        data["color"] = "black";
        data["shape"] = "hexagon";
    } else {
        if (data.cat.startsWith("router")) {
            data["shape"] = "dot";
            data["size"] = 10;
        } else {
            data["shape"] = "box";
        }
    }
    sDG(sDO, sEV, sDP, sDQ, sDR, sDS, sDT);
    sEJ();
    callback(data);
    sAF[data.id].id = data.id;
    sAF[data.id].label = data.label;
    sAF[data.id].address = data.address;
    sAF[data.id].group = data.group;
    sAF[data.id].type = data.type;
    sAF[data.id].cat = data.cat;
    sAF[data.id].route = data.route;
    sAF[data.id].ethernet = data.ethernet;
    sAF[data.id].title = data.title;
    if (sAE.indexOf(data.group) == -1) {
        sAE.push(data.group);
        sEA = sDZ(data.group);
        nodes.add(sEA);
    }
    sGC();
}
function sEU() {
    sAD.forEach((sDH) => {
        let sDO = sDH.cat;
        let sEV = sDH.type;
        let sDP = sDH.addr;
        let sEW = sCS(sDP);
        let sDQ = sDH.mask;
        let sDR = sDH.network;
        let sDS = sDH.route;
        let sDT = sDH.ethernet;
        if (sAE.indexOf(sDR) == -1) {
            sAE.push(sDR);
        }
        sAC = sAC + 1;
        let sEP = {};
        sEP["id"] = sAC;
        sEP["label"] = sDP + "/" + sDQ;
        sEP["address"] = sDP + "/" + sDQ;
        sEP["group"] = sDR;
        sEP["type"] = sEV;
        sEP["cat"] = sDO;
        sEP["route"] = sDS;
        sEP["ethernet"] = sDT;
        let sEX = sEC(sDS);
        sEP["title"] = sEX;
        sEP["mass"] = 4;
        if (sEP.cat.startsWith("router")) {
            sEP["shape"] = "dot";
            sEP["size"] = 10;
        } else {
            sEP["shape"] = "box";
        }
        if (sEV == "bad_interface" || sEV == "bad_route") {
            sEP["color"] = "black";
            sEP["shape"] = "hexagon";
        }
        sAF.push(sEP);
    });
}
function sEY() {
    sAG = [];
    sAF.forEach((scrNode) => {
        sAF.forEach((dstNode) => {
            if (scrNode.id != dstNode.id && scrNode.cat != "switchEth" && dstNode.cat != "switchEth") {
                var sEZ = {};
                var sFA = scrNode.address.split("/");
                var sFB = sFA[0];
                var sFC = sFB.split(".");
                var sFD = sFA[1];
                var sFE = sBZ(sFD);
                var sFF = sAR(sFC, sFE);
                var sFG = sAL2Str(sFF);
                var sFH = dstNode.address.split("/");
                var sFI = sFH[0];
                var sFJ = sFI.split(".");
                var sFK = sFH[1];
                var sFL = sBZ(sFK);
                sEZ["from"] = scrNode.id;
                sEZ["to"] = dstNode.id;
                sEZ["shadow"] = true;
                sEZ["length"] = 300;
                matchRouteFlag = false;
                var sDLsTab = scrNode.route.split(";");
                for (let iLine = 0; iLine < sDLsTab.length; iLine++) {
                    var sEG = sDLsTab[iLine].split(",");
                    var sFM = sEG[0];
                    var sFN = sEG[1];
                    var sFO = sBZ(sFN);
                    var sFP = sEG[2];
                    var sFQ = sAR(sFJ, sFO);
                    var sFR = sAL2Str(sFQ);
                    if (sFM == sFR) {
                        matchRouteFlag = true;
                        var sFS = sAL2Bin(sFO);
                        var sFSSliced = sCM(sFS, sFN);
                        var sFU = sAL2Bin(sFJ);
                        var sFUSliced = sCM(sFU, sFN);
                        var dstSubnetIDsFS = sAL2Bin(sFQ);
                        var dstSubnetIDsFSSliced = sCM(dstSubnetIDsFS, sFN);
                        sEZ["title"] = sEH(
                            sFI,
                            sFUSliced,
                            scrNode.route,
                            sFM,
                            sFSSliced,
                            dstSubnetIDsFSSliced
                        );
                        if (scrNode.group == dstNode.group) {
                            sEZ["relation"] = "inside";
                            sEZ["label"] = "inside";
                        } else {
                            sEZ["dashes"] = true;
                            sEZ["relation"] = "outside";
                            sEZ["label"] = "outside";
                        }
                        if (sFP == "") {
                            sEZ["label"] = "IP direct\n" + sEZ["label"];
                        } else {
                            sEZ["label"] = "IP gateway\n" + sEZ["label"] + "\nvia " + sFP;
                            sEZ["relation"] = "routed";
                            sEZ["width"] = 2;
                            sEZ["dashes"] = [2, 10, 2, 10, 10, 10];
                        }
                        if (matchRouteFlag) {
                            sEZ["label"] = sEZ["label"] + "\n" + sFM + " | /" + sFN + " | " + sFP;
                            break;
                        }
                    }
                }
                consistantFlag = false;
                for (let iLine = 0; iLine < sDLsTab.length; iLine++) {
                    var sEG = sDLsTab[iLine].split(",");
                    var sFM = sEG[0];
                    var sFN = sEG[1];
                    var sFO = sBZ(sFN);
                    var sFY = sAR(sFC, sFO);
                    var sFZ = sAL2Str(sFY);
                    if (sFM == sFZ) {
                        consistantFlag = true;
                    }
                }
                if (matchRouteFlag && !consistantFlag) {
                    sEZ["relation"] = "bad_routing";
                    sEZ["label"] = "IP\ninconsistent\nsubnetting";
                    sEZ["color"] = "#000000";
                    sEZ["width"] = 2;
                }
                sEZ["arrows"] = "to";
                sAG.push(sEZ);
            }
            if (scrNode.cat != "switchEth" && dstNode.cat == "switchEth") {
                if (scrNode.group == dstNode.group) {
                    let sEZEthernet = {};
                    sEZEthernet["from"] = scrNode.id;
                    sEZEthernet["to"] = dstNode.id;
                    sEZEthernet["shadow"] = true;
                    sEZEthernet["relation"] = "ethernet";
                    sEZEthernet["label"] = "Ethernet";
                    sEZEthernet["label"] = scrNode.ethernet;
                    sEZEthernet["width"] = 4;
                    sAG.push(sEZEthernet);
                }
            }
            if (scrNode.id < dstNode.id) {
                if (scrNode.cat.startsWith("router") && scrNode.cat == dstNode.cat) {
                    let sET = scrNode.cat.substr(scrNode.cat.length - 1);
                    if (sAH[sET]) {
                        let sEZ = {};
                        sEZ["from"] = scrNode.id;
                        sEZ["to"] = dstNode.id;
                        sEZ["shadow"] = true;
                        sEZ["label"] = "Router " + sET.toString();
                        sEZ["length"] = 10;
                        sEZ["width"] = 4;
                        sEZ["relation"] = "router";
                        sEZ["color"] = "#000000";
                        sAG.push(sEZ);
                    }
                }
            }
        });
    });
}
function sGB() {
    const nodesFilterValues = {
        router: true,
        standard: true,
        subnet: false,
        classless: false,
        add_gateway: true,
        bad_interface: true,
        bad_route: true,
        switchEth: false,
    };
    const edgesFilterValues = {
        inside: true,
        bad_routing: true,
        outside: false,
        routed: false,
        ethernet: true,
        router: true,
    };
    const nodesFilter = (node) => {
        return nodesFilterValues[node.type];
    };
    const edgesFilter = (edge) => {
        return edgesFilterValues[edge.relation];
    };
    nodes = new vis.DataSet(sAF);
    edges = new vis.DataSet(sAG);
    const nodesView = new vis.DataView(nodes, { filter: nodesFilter });
    const edgesView = new vis.DataView(edges, { filter: edgesFilter });
    nodeFilters.forEach((filter) =>
        filter.addEventListener("change", (e) => {
            const { value, checked } = e.target;
            nodesFilterValues[value] = checked;
            nodesView.refresh();
        })
    );
    edgeFilters.forEach((filter) =>
        filter.addEventListener("change", (e) => {
            const { value, checked } = e.target;
            edgesFilterValues[value] = checked;
            edgesView.refresh();
        })
    );
    sAA = { nodes: nodesView, edges: edgesView };
}
function sGC() {
    for (let edgeSelected of sAG) {
        edges.remove(edgeSelected);
    }
    sEY();
    for (let edgeSelected of sAG) {
        edges.add(edgeSelected);
    }
}
function sGD(data) {
    const container = document.getElementById("mynetwork");
    const options = {
        interaction: { keyboard: true },
        manipulation: {
            addNode: function (data, callback) {
                document.getElementById("operation").innerText = "Add Node";
                document.getElementById("node-id").value = -1;
                document.getElementById("node-cat").value = "";
                document.getElementById("node-type").value = "";
                document.getElementById("node-network-number").value = "0";
                let sER = document.getElementById("node-ethernet");
                sER.rows[0].cells[1].textContent = sCJ();
                document.getElementById("node-address").value = "";
                document.getElementById("node-mask").value = "";
                for (iLine = 1; iLine < 5; iLine++) {
                    document.getElementById("node-routing-destination-" + iLine.toString()).value = "";
                    document.getElementById("node-routing-mask-" + iLine.toString()).value = "";
                    document.getElementById("node-routing-gateway-" + iLine.toString()).value = "";
                }
                document.getElementById("saveButton").onclick = sEM.bind(this, data, callback);
                document.getElementById("cancelButton").onclick = sEJ.bind();
                document.getElementById("network-popUp").style.display = "block";
            },
            editNode: function (data, callback) {
                if (data.cat == "switchEth") {
                    sAI("Switch can not be edited");
                    callback(null);
                    return;
                }
                document.getElementById("operation").innerText = "Edit Node";
                document.getElementById("node-id").value = data.id;
                document.getElementById("node-cat").value = data.cat;
                document.getElementById("node-type").value = data.type;
                document.getElementById("node-network-number").value = data.group;
                let sER = document.getElementById("node-ethernet");
                sER.rows[0].cells[1].textContent = data.ethernet;
                const labelSplited = sCT(data.address);
                document.getElementById("node-address").value = labelSplited.addr;
                document.getElementById("node-mask").value = labelSplited.mask;
                var sGE = data.route.split(";");
                for (iLine = 1; iLine < 5; iLine++) {
                    let sGF = sGE[iLine - 1];
                    if (sGF === undefined || sGF == "") {
                        document.getElementById("node-routing-destination-" + iLine.toString()).value = "";
                        document.getElementById("node-routing-mask-" + iLine.toString()).value = "";
                        document.getElementById("node-routing-gateway-" + iLine.toString()).value = "";
                    } else {
                        const routeLineSplited = sCG(sGE[iLine - 1]);
                        document.getElementById("node-routing-destination-" + iLine.toString()).value =
                            routeLineSplited.addr;
                        document.getElementById("node-routing-mask-" + iLine.toString()).value =
                            routeLineSplited.mask;
                        document.getElementById("node-routing-gateway-" + iLine.toString()).value =
                            routeLineSplited.gateway;
                    }
                }
                document.getElementById("saveButton").onclick = sEM.bind(this, data, callback);
                document.getElementById("cancelButton").onclick = sEK.bind(this, callback);
                document.getElementById("network-popUp").style.display = "block";
                sAB.unselectAll();
            },
            deleteNode: function (data, callback) {
                let sGG = data.nodes[0];
                for (let iIndex = 0; iIndex < sAF.length; iIndex++) {
                    if (sAF[iIndex].id == sGG) {
                        if (sAF[iIndex].cat == "switchEth") {
                            sAI("Switch can not be deleted");
                            callback(null);
                        }
                    }
                }
                callback(data);
                sAB.unselectAll();
                return;
            },
        },
        physics: { enabled: true, solver: "repulsion", repulsion: { nodeDistance: 150 } },
    };
    sAB = new vis.Network(container, data, options);
}
function clusterByRouter() {
    sAB.setData(sAA);
    var sGH;
    for (let nRouter = 1; nRouter <= maxRouter; nRouter++) {
        let sGI = "router " + nRouter.toString();
        sGH = {
            joinCondition: function (childOptions) {
                return childOptions.cat == sGI;
            },
            processProperties: function (clusterOptions, childNodes, childEdges) {
                var sGJ = 0;
                var sDU = true;
                var sDS = "";
                for (let iNode = 0; iNode < childNodes.length; iNode++) {
                    sGJ += childNodes[iNode].mass;
                    let sET = childNodes[iNode].cat.substr(childNodes[iNode].cat.length - 1);
                    sAH[sET] = false;
                    if (!sDU) {
                        sDS = sDS + ";";
                    }
                    sDU = false;
                    sDS = sDS + childNodes[iNode].route;
                }
                clusterOptions.mass = sGJ;
                clusterOptions.title = sEC(sDS);
                return clusterOptions;
            },
            clusterNodeProperties: {
                id: "cluster:" + sGI,
                borderWidth: 3,
                shape: "database",
                group: sGI,
                label: sGI,
            },
        };
        edgeRouterFlag = false;
        sAB.cluster(sGH);
    }
    sGC();
}
function previewFile() {
    const content = document.querySelector(".content");
    const [file] = document.querySelector("input[type=file]").files;
    const reader = new FileReader();
    reader.addEventListener(
        "load",
        () => {
            sDI(reader.result);
            sEU();
            sDY();
            sEY();
            sGB();
            sGD(sAA);
            sAB.on("selectNode", function (params) {
                if (params.nodes.length == 1) {
                    if (sAB.isCluster(params.nodes[0]) == true) {
                        sAB.openCluster(params.nodes[0]);
                        let sET = params.nodes[0].substr(params.nodes[0].length - 1);
                        sAH[sET] = true;
                        sGC();
                    }
                }
            });
            document.getElementById("select").style.display = "none";
            document.getElementById("logs").style.display = "block";
        },
        false
    );
    if (file) {
        reader.readAsText(file);
    }
}
function nopreviewFile() {
    document.getElementById("select").style.display = "none";
    document.getElementById("logs").style.display = "block";
    sEU();
    sDY();
    sEY();
    sGB();
    sGD(sAA);
    sAB.on("selectNode", function (params) {
        if (params.nodes.length == 1) {
            if (sAB.isCluster(params.nodes[0]) == true) {
                sAB.openCluster(params.nodes[0]);
                let sET = params.nodes[0].substr(params.nodes[0].length - 1);
                sAH[sET] = true;
                sGC();
            }
        }
    });
}
